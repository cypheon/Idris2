{__mainExpression:0} = []: [DECLARE v0, START, v0 := CALL Main.main(), RVAL := TAILCALL PrimIO.unsafePerformIO(DISCARD, v0)]
prim__add_Int = [0, 1]: [START, RVAL := OP +Int(v0, v1)]
prim__add_Integer = [0, 1]: [START, RVAL := OP +Integer(v0, v1)]
prim__sub_Int = [0, 1]: [START, RVAL := OP -Int(v0, v1)]
prim__sub_Integer = [0, 1]: [START, RVAL := OP -Integer(v0, v1)]
prim__mul_Int = [0, 1]: [START, RVAL := OP *Int(v0, v1)]
prim__mul_Integer = [0, 1]: [START, RVAL := OP *Integer(v0, v1)]
prim__div_Int = [0, 1]: [START, RVAL := OP /Int(v0, v1)]
prim__div_Integer = [0, 1]: [START, RVAL := OP /Integer(v0, v1)]
prim__mod_Int = [0, 1]: [START, RVAL := OP %Int(v0, v1)]
prim__mod_Integer = [0, 1]: [START, RVAL := OP %Integer(v0, v1)]
prim__lt_Integer = [0, 1]: [START, RVAL := OP <Integer(v0, v1)]
prim__lte_Integer = [0, 1]: [START, RVAL := OP <=Integer(v0, v1)]
prim__eq_Int = [0, 1]: [START, RVAL := OP ==Int(v0, v1)]
prim__eq_Integer = [0, 1]: [START, RVAL := OP ==Integer(v0, v1)]
prim__eq_Char = [0, 1]: [START, RVAL := OP ==Char(v0, v1)]
prim__gte_Integer = [0, 1]: [START, RVAL := OP >=Integer(v0, v1)]
prim__gt_Integer = [0, 1]: [START, RVAL := OP >Integer(v0, v1)]
prim__strHead = [0]: [START, RVAL := OP op_strhead(v0)]
prim__strAppend = [0, 1]: [START, RVAL := OP ++(v0, v1)]
prim__believe_me = [0, 1, 2]: [START, RVAL := OP believe_me(v0, v1, v2)]
prim__crash = [0, 1]: [START, RVAL := OP crash(v0, v1)]
prim__cast_IntString = [0]: [START, RVAL := OP cast-Int-String(v0)]
prim__cast_IntegerString = [0]: [START, RVAL := OP cast-Integer-String(v0)]
prim__cast_IntegerInt = [0]: [START, RVAL := OP cast-Integer-Int(v0)]
Main.2348:825:results = [0, 1]: [DECLARE v2, DECLARE v3, START, v2 := MKCLOSURE Main.{2348:825:results:0} 1 (v0, v1), v3 := CALL Main.binOps(DISCARD, v1), RVAL := TAILCALL Prelude.Types.map(DISCARD, DISCARD, v2, v3)]
Main.{2348:825:results:0} = [0, 1, 2]: [DECLARE v3, DECLARE v4, DECLARE v5, START, v3 := CALL Main.large(v0), v4 := v2 @ v3, v5 := CALL Main.small(v0), RVAL := v4 @ v5]
Main.small = [0]: [DECLARE v1, DECLARE v2, START, CASE v0 [(Right Integer, [RVAL := MKCONSTANT 437]), (Right Int, [v1 := MKCONSTANT 377, RVAL := OP cast-Integer-Int(v1)])] {default: Just [v2 := MKCONSTANT "Unhandled input for Main.small at Numbers.idr:15:1--15:20", RVAL := TAILCALL Builtin.idris_crash(DISCARD, v2)]}]
Main.numOps = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v10, DECLARE v5, DECLARE v6, DECLARE v7, DECLARE v8, DECLARE v9, DECLARE v11, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), v4 := PROJECT(v1, 2), v10 := MKCLOSURE Main.{numOps:0} 2 (v2, v3, v4, v0, v1)])] {default: Nothing}, CASE v1 [(Left 0, [v5 := PROJECT(v1, 0), v6 := PROJECT(v1, 1), v7 := PROJECT(v1, 2), v8 := MKCLOSURE Main.{numOps:1} 2 (v5, v6, v7, v0, v1)])] {default: Nothing}, v9 := MKCON Left 0 (), v11 := MKCON Left 1 (v8, v9), RVAL := MKCON Left 1 (v10, v11)]
Main.{numOps:1} = [0, 1, 2, 3, 4, 6, 5]: [DECLARE v7, START, v7 := v1 @ v6, RVAL := v7 @ v5]
Main.{numOps:0} = [0, 1, 2, 3, 4, 6, 5]: [DECLARE v7, START, v7 := v0 @ v6, RVAL := v7 @ v5]
Main.negOps = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, DECLARE v6, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), v4 := PROJECT(v1, 2), v5 := MKCLOSURE Main.{negOps:0} 2 (v2, v3, v4, v0, v1)])] {default: Nothing}, v6 := MKCON Left 0 (), RVAL := MKCON Left 1 (v5, v6)]
Main.{negOps:0} = [0, 1, 2, 3, 4, 6, 5]: [DECLARE v7, START, v7 := v2 @ v6, RVAL := v7 @ v5]
Main.main = []: [DECLARE v0, DECLARE v1, DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, DECLARE v41, DECLARE v6, DECLARE v7, DECLARE v8, DECLARE v9, DECLARE v10, DECLARE v11, DECLARE v12, DECLARE v13, DECLARE v39, DECLARE v14, DECLARE v15, DECLARE v37, DECLARE v35, DECLARE v16, DECLARE v17, DECLARE v18, DECLARE v33, DECLARE v19, DECLARE v20, DECLARE v21, DECLARE v22, DECLARE v23, DECLARE v24, DECLARE v31, DECLARE v25, DECLARE v26, DECLARE v27, DECLARE v28, DECLARE v29, DECLARE v30, DECLARE v32, DECLARE v34, DECLARE v36, DECLARE v38, DECLARE v40, DECLARE v42, DECLARE v43, START, v0 := MKCLOSURE Main.{main:0} 5 (), v1 := MKCLOSURE Main.{main:1} 3 (), v2 := MKCLOSURE Main.{main:2} 5 (), v3 := MKCON Left 0 (v0, v1, v2), v4 := MKCLOSURE Main.{main:3} 5 (), v5 := MKCLOSURE Main.{main:4} 3 (), v41 := MKCON Left 0 (v3, v4, v5), v6 := MKCLOSURE Main.{main:5} 5 (), v7 := MKCLOSURE Main.{main:6} 3 (), v8 := MKCLOSURE Main.{main:7} 5 (), v9 := MKCON Left 0 (v6, v7, v8), v10 := MKCLOSURE Main.{main:8} 5 (), v11 := MKCLOSURE Main.{main:9} 3 (), v12 := MKCON Left 0 (v9, v10, v11), v13 := MKCLOSURE Main.{main:10} 2 (), v39 := MKCON Left 0 (v12, v13), v14 := MKCLOSURE Main.{main:11} 1 (), v15 := MKCLOSURE Main.{main:12} 2 (), v37 := MKCON Left 0 (v14, v15), v35 := MKCON Right Integer (), v16 := MKCLOSURE Main.{main:13} 2 (), v17 := MKCLOSURE Main.{main:14} 2 (), v18 := MKCLOSURE Main.{main:15} 1 (), v33 := MKCON Left 0 (v16, v17, v18), v19 := MKCLOSURE Main.{main:16} 2 (), v20 := MKCLOSURE Main.{main:17} 2 (), v21 := MKCLOSURE Main.{main:18} 1 (), v22 := MKCON Left 0 (v19, v20, v21), v23 := MKCLOSURE Main.{main:19} 1 (), v24 := MKCLOSURE Main.{main:20} 2 (), v31 := MKCON Left 0 (v22, v23, v24), v25 := MKCLOSURE Main.{main:21} 2 (), v26 := MKCLOSURE Main.{main:22} 2 (), v27 := MKCLOSURE Main.{main:23} 1 (), v28 := MKCON Left 0 (v25, v26, v27), v29 := MKCLOSURE Main.{main:24} 2 (), v30 := MKCLOSURE Main.{main:25} 2 (), v32 := MKCON Left 0 (v28, v29, v30), v34 := MKCON Left 0 (v31, v32), v36 := MKCON Left 0 (v33, v34), v38 := CALL Main.2348:825:results(v35, v36), v40 := CALL Prelude.Show.show(DISCARD, v37, v38), v42 := CALL Prelude.IO.putStrLn(DISCARD, v39, v40), v43 := MKCLOSURE Main.{main:47} 1 (), RVAL := TAILCALL Prelude.Interfaces.>>(DISCARD, DISCARD, v41, v42, v43)]
Main.{main:47} = [0]: [DECLARE v1, DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, DECLARE v6, DECLARE v7, DECLARE v8, DECLARE v34, DECLARE v9, DECLARE v10, DECLARE v32, DECLARE v30, DECLARE v11, DECLARE v12, DECLARE v13, DECLARE v28, DECLARE v14, DECLARE v15, DECLARE v16, DECLARE v17, DECLARE v18, DECLARE v19, DECLARE v26, DECLARE v20, DECLARE v21, DECLARE v22, DECLARE v23, DECLARE v24, DECLARE v25, DECLARE v27, DECLARE v29, DECLARE v31, DECLARE v33, DECLARE v35, START, v1 := MKCLOSURE Main.{main:26} 5 (v0), v2 := MKCLOSURE Main.{main:27} 3 (v0), v3 := MKCLOSURE Main.{main:28} 5 (v0), v4 := MKCON Left 0 (v1, v2, v3), v5 := MKCLOSURE Main.{main:29} 5 (v0), v6 := MKCLOSURE Main.{main:30} 3 (v0), v7 := MKCON Left 0 (v4, v5, v6), v8 := MKCLOSURE Main.{main:31} 2 (v0), v34 := MKCON Left 0 (v7, v8), v9 := MKCLOSURE Main.{main:32} 1 (v0), v10 := MKCLOSURE Main.{main:33} 2 (v0), v32 := MKCON Left 0 (v9, v10), v30 := MKCON Right Int (), v11 := MKCLOSURE Main.{main:34} 2 (v0), v12 := MKCLOSURE Main.{main:35} 2 (v0), v13 := MKCLOSURE Main.{main:36} 1 (v0), v28 := MKCON Left 0 (v11, v12, v13), v14 := MKCLOSURE Main.{main:37} 2 (v0), v15 := MKCLOSURE Main.{main:38} 2 (v0), v16 := MKCLOSURE Main.{main:39} 1 (v0), v17 := MKCON Left 0 (v14, v15, v16), v18 := MKCLOSURE Main.{main:40} 1 (v0), v19 := MKCLOSURE Main.{main:41} 2 (v0), v26 := MKCON Left 0 (v17, v18, v19), v20 := MKCLOSURE Main.{main:42} 2 (v0), v21 := MKCLOSURE Main.{main:43} 2 (v0), v22 := MKCLOSURE Main.{main:44} 1 (v0), v23 := MKCON Left 0 (v20, v21, v22), v24 := MKCLOSURE Main.{main:45} 2 (v0), v25 := MKCLOSURE Main.{main:46} 2 (v0), v27 := MKCON Left 0 (v23, v24, v25), v29 := MKCON Left 0 (v26, v27), v31 := MKCON Left 0 (v28, v29), v33 := CALL Main.2348:825:results(v30, v31), v35 := CALL Prelude.Show.show(DISCARD, v32, v33), RVAL := TAILCALL Prelude.IO.putStrLn(DISCARD, v34, v35)]
Main.{main:46} = [0, 2, 1]: [START, RVAL := TAILCALL Prelude.Num.mod(v2, v1)]
Main.{main:45} = [0, 2, 1]: [START, RVAL := TAILCALL Prelude.Num.div(v2, v1)]
Main.{main:44} = [0, 1]: [START, RVAL := OP cast-Integer-Int(v1)]
Main.{main:43} = [0, 2, 1]: [START, RVAL := OP *Int(v2, v1)]
Main.{main:42} = [0, 2, 1]: [START, RVAL := OP +Int(v2, v1)]
Main.{main:41} = [0, 2, 1]: [START, RVAL := TAILCALL Prelude.Num.-(v2, v1)]
Main.{main:40} = [0, 1]: [START, RVAL := TAILCALL Prelude.Num.negate(v1)]
Main.{main:39} = [0, 1]: [START, RVAL := OP cast-Integer-Int(v1)]
Main.{main:38} = [0, 2, 1]: [START, RVAL := OP *Int(v2, v1)]
Main.{main:37} = [0, 2, 1]: [START, RVAL := OP +Int(v2, v1)]
Main.{main:36} = [0, 1]: [START, RVAL := OP cast-Integer-Int(v1)]
Main.{main:35} = [0, 2, 1]: [START, RVAL := OP *Int(v2, v1)]
Main.{main:34} = [0, 2, 1]: [START, RVAL := OP +Int(v2, v1)]
Main.{main:33} = [0, 2, 1]: [START, RVAL := TAILCALL Prelude.Show.showPrec(v2, v1)]
Main.{main:32} = [0, 1]: [START, RVAL := TAILCALL Prelude.Show.show(v1)]
Main.{main:31} = [0, 2, 1]: [START, RVAL := v1]
Main.{main:30} = [0, 3, 2, 1]: [DECLARE v4, START, v4 := v2 @ v1, RVAL := v4 @ v1]
Main.{main:29} = [0, 5, 4, 3, 2, 1]: [DECLARE v6, DECLARE v7, START, v6 := v3 @ v1, v7 := v2 @ v6, RVAL := v7 @ v1]
Main.{main:28} = [0, 5, 4, 3, 2, 1]: [DECLARE v6, DECLARE v7, START, v6 := v3 @ v1, v7 := v2 @ v1, RVAL := v6 @ v7]
Main.{main:27} = [0, 3, 2, 1]: [START, RVAL := v2]
Main.{main:26} = [0, 5, 4, 3, 2, 1]: [START, RVAL := TAILCALL Prelude.IO.map(DISCARD, DISCARD, v3, v2, v1)]
Main.{main:25} = [1, 0]: [START, RVAL := TAILCALL Prelude.Num.mod(v1, v0)]
Main.{main:24} = [1, 0]: [START, RVAL := TAILCALL Prelude.Num.div(v1, v0)]
Main.{main:23} = [0]: [START, RVAL := v0]
Main.{main:22} = [1, 0]: [START, RVAL := OP *Integer(v1, v0)]
Main.{main:21} = [1, 0]: [START, RVAL := OP +Integer(v1, v0)]
Main.{main:20} = [1, 0]: [START, RVAL := TAILCALL Prelude.Num.-(v1, v0)]
Main.{main:19} = [0]: [START, RVAL := TAILCALL Prelude.Num.negate(v0)]
Main.{main:18} = [0]: [START, RVAL := v0]
Main.{main:17} = [1, 0]: [START, RVAL := OP *Integer(v1, v0)]
Main.{main:16} = [1, 0]: [START, RVAL := OP +Integer(v1, v0)]
Main.{main:15} = [0]: [START, RVAL := v0]
Main.{main:14} = [1, 0]: [START, RVAL := OP *Integer(v1, v0)]
Main.{main:13} = [1, 0]: [START, RVAL := OP +Integer(v1, v0)]
Main.{main:12} = [1, 0]: [START, RVAL := TAILCALL Prelude.Show.showPrec(v1, v0)]
Main.{main:11} = [0]: [START, RVAL := TAILCALL Prelude.Show.show(v0)]
Main.{main:10} = [1, 0]: [START, RVAL := v0]
Main.{main:9} = [2, 1, 0]: [DECLARE v3, START, v3 := v1 @ v0, RVAL := v3 @ v0]
Main.{main:8} = [4, 3, 2, 1, 0]: [DECLARE v5, DECLARE v6, START, v5 := v2 @ v0, v6 := v1 @ v5, RVAL := v6 @ v0]
Main.{main:7} = [4, 3, 2, 1, 0]: [DECLARE v5, DECLARE v6, START, v5 := v2 @ v0, v6 := v1 @ v0, RVAL := v5 @ v6]
Main.{main:6} = [2, 1, 0]: [START, RVAL := v1]
Main.{main:5} = [4, 3, 2, 1, 0]: [START, RVAL := TAILCALL Prelude.IO.map(DISCARD, DISCARD, v2, v1, v0)]
Main.{main:4} = [2, 1, 0]: [DECLARE v3, START, v3 := v1 @ v0, RVAL := v3 @ v0]
Main.{main:3} = [4, 3, 2, 1, 0]: [DECLARE v5, DECLARE v6, START, v5 := v2 @ v0, v6 := v1 @ v5, RVAL := v6 @ v0]
Main.{main:2} = [4, 3, 2, 1, 0]: [DECLARE v5, DECLARE v6, START, v5 := v2 @ v0, v6 := v1 @ v0, RVAL := v5 @ v6]
Main.{main:1} = [2, 1, 0]: [START, RVAL := v1]
Main.{main:0} = [4, 3, 2, 1, 0]: [START, RVAL := TAILCALL Prelude.IO.map(DISCARD, DISCARD, v2, v1, v0)]
Main.large = [0]: [DECLARE v1, DECLARE v2, START, CASE v0 [(Right Integer, [RVAL := MKCONSTANT 3518437212345678901234567890123]), (Right Int, [v1 := MKCONSTANT 3518437212345678901234567890, RVAL := OP cast-Integer-Int(v1)])] {default: Just [v2 := MKCONSTANT "Unhandled input for Main.large at Numbers.idr:9:1--9:48", RVAL := TAILCALL Builtin.idris_crash(DISCARD, v2)]}]
Main.integralOps = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v10, DECLARE v5, DECLARE v6, DECLARE v7, DECLARE v8, DECLARE v9, DECLARE v11, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), v4 := PROJECT(v1, 2), v10 := MKCLOSURE Main.{integralOps:0} 2 (v2, v3, v4, v0, v1)])] {default: Nothing}, CASE v1 [(Left 0, [v5 := PROJECT(v1, 0), v6 := PROJECT(v1, 1), v7 := PROJECT(v1, 2), v8 := MKCLOSURE Main.{integralOps:1} 2 (v5, v6, v7, v0, v1)])] {default: Nothing}, v9 := MKCON Left 0 (), v11 := MKCON Left 1 (v8, v9), RVAL := MKCON Left 1 (v10, v11)]
Main.{integralOps:1} = [0, 1, 2, 3, 4, 6, 5]: [DECLARE v7, START, v7 := v2 @ v6, RVAL := v7 @ v5]
Main.{integralOps:0} = [0, 1, 2, 3, 4, 6, 5]: [DECLARE v7, START, v7 := v1 @ v6, RVAL := v7 @ v5]
Main.binOps = [0, 1]: [DECLARE v2, DECLARE v9, DECLARE v3, DECLARE v4, DECLARE v7, DECLARE v5, DECLARE v6, DECLARE v8, DECLARE v10, START, v2 := CALL Builtin.fst(DISCARD, DISCARD, v1), v9 := CALL Main.numOps(DISCARD, v2), v3 := CALL Builtin.snd(DISCARD, DISCARD, v1), v4 := CALL Builtin.fst(DISCARD, DISCARD, v3), v7 := CALL Main.negOps(DISCARD, v4), v5 := CALL Builtin.snd(DISCARD, DISCARD, v1), v6 := CALL Builtin.snd(DISCARD, DISCARD, v5), v8 := CALL Main.integralOps(DISCARD, v6), v10 := CALL Prelude.Types.List.++(DISCARD, v7, v8), RVAL := TAILCALL Prelude.Types.List.++(DISCARD, v9, v10)]
Prelude.Basics.not = [0]: [START, CASE v0 [(0, [RVAL := MKCONSTANT 1]), (1, [RVAL := MKCONSTANT 0])] {default: Nothing}]
Prelude.Basics.intToBool = [0]: [START, CASE v0 [(0, [RVAL := MKCONSTANT 1])] {default: Just [RVAL := MKCONSTANT 0]}]
Prelude.Basics.id = [0, 1]: [START, RVAL := v1]
Prelude.Basics.&& = [0, 1]: [START, CASE v0 [(0, [RVAL := v1 @ DISCARD]), (1, [RVAL := MKCONSTANT 1])] {default: Nothing}]
Builtin.snd = [0, 1, 2]: [DECLARE v3, DECLARE v4, START, CASE v2 [(Left 0, [v3 := PROJECT(v2, 0), v4 := PROJECT(v2, 1), RVAL := v4])] {default: Nothing}]
Builtin.idris_crash = [0, 1]: [START, RVAL := OP crash(DISCARD, v1)]
Builtin.fst = [0, 1, 2]: [DECLARE v3, DECLARE v4, START, CASE v2 [(Left 0, [v3 := PROJECT(v2, 0), v4 := PROJECT(v2, 1), RVAL := v3])] {default: Nothing}]
Builtin.believe_me = [0, 1, 2]: [START, RVAL := OP believe_me(DISCARD, DISCARD, v2)]
Builtin.assert_total = [0, 1]: [START, RVAL := v1]
Prelude.Types.case block in max = [0, 1, 2]: [START, CASE v2 [(0, [RVAL := v1]), (1, [RVAL := v0])] {default: Nothing}]
Prelude.Types.case block in min = [0, 1, 2]: [START, CASE v2 [(0, [RVAL := v1]), (1, [RVAL := v0])] {default: Nothing}]
Prelude.Types.case block in prim__integerToNat = [0, 1]: [START, CASE v1 [(0, [RVAL := TAILCALL Builtin.believe_me(DISCARD, DISCARD, v0)]), (1, [RVAL := MKCONSTANT 0])] {default: Nothing}]
Prelude.Types.min = [0, 1]: [DECLARE v2, START, v2 := CALL Prelude.Types.<(v0, v1), RVAL := TAILCALL Prelude.Types.case block in min(v1, v0, v2)]
Prelude.Types.max = [0, 1]: [DECLARE v2, START, v2 := CALL Prelude.Types.>(v0, v1), RVAL := TAILCALL Prelude.Types.case block in max(v1, v0, v2)]
Prelude.Types.map = [0, 1, 2, 3]: [DECLARE v4, DECLARE v5, DECLARE v6, DECLARE v7, START, CASE v3 [(Left 0, [RVAL := MKCON Left 0 ()]), (Left 1, [v4 := PROJECT(v3, 0), v5 := PROJECT(v3, 1), v6 := v2 @ v4, v7 := CALL Prelude.Types.map(DISCARD, DISCARD, v2, v5), RVAL := MKCON Left 1 (v6, v7)])] {default: Nothing}]
Prelude.Types.compare = [0, 1]: [DECLARE v3, DECLARE v2, DECLARE v5, DECLARE v4, START, CASE v0 [(0, [CASE v1 [(0, [RVAL := MKCONSTANT 1])] {default: Just [RVAL := MKCONSTANT 0]}])] {default: Just [v3 := MKCONSTANT 1, v2 := OP -Integer(v0, v3), CASE v1 [(0, [RVAL := MKCONSTANT 2])] {default: Just [v5 := MKCONSTANT 1, v4 := OP -Integer(v1, v5), RVAL := TAILCALL Prelude.Types.compare(v2, v4)]}]}]
Prelude.Types.Ord implementation at Prelude/Types.idr:77:1--82:36 = []: [DECLARE v0, DECLARE v1, DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, DECLARE v6, DECLARE v7, DECLARE v8, DECLARE v9, START, v0 := MKCLOSURE Prelude.Types.{__Impl_Ord_Nat:0} 2 (), v1 := MKCLOSURE Prelude.Types.{__Impl_Ord_Nat:1} 2 (), v2 := MKCON Left 0 (v0, v1), v3 := MKCLOSURE Prelude.Types.{__Impl_Ord_Nat:2} 2 (), v4 := MKCLOSURE Prelude.Types.{__Impl_Ord_Nat:3} 2 (), v5 := MKCLOSURE Prelude.Types.{__Impl_Ord_Nat:4} 2 (), v6 := MKCLOSURE Prelude.Types.{__Impl_Ord_Nat:5} 2 (), v7 := MKCLOSURE Prelude.Types.{__Impl_Ord_Nat:6} 2 (), v8 := MKCLOSURE Prelude.Types.{__Impl_Ord_Nat:7} 2 (), v9 := MKCLOSURE Prelude.Types.{__Impl_Ord_Nat:8} 2 (), RVAL := MKCON Left 0 (v2, v3, v4, v5, v6, v7, v8, v9)]
Prelude.Types.{__Impl_Ord_Nat:8} = [1, 0]: [START, RVAL := TAILCALL Prelude.Types.min(v1, v0)]
Prelude.Types.{__Impl_Ord_Nat:7} = [1, 0]: [START, RVAL := TAILCALL Prelude.Types.max(v1, v0)]
Prelude.Types.{__Impl_Ord_Nat:6} = [1, 0]: [START, RVAL := TAILCALL Prelude.Types.>=(v1, v0)]
Prelude.Types.{__Impl_Ord_Nat:5} = [1, 0]: [START, RVAL := TAILCALL Prelude.Types.<=(v1, v0)]
Prelude.Types.{__Impl_Ord_Nat:4} = [1, 0]: [START, RVAL := TAILCALL Prelude.Types.>(v1, v0)]
Prelude.Types.{__Impl_Ord_Nat:3} = [1, 0]: [START, RVAL := TAILCALL Prelude.Types.<(v1, v0)]
Prelude.Types.{__Impl_Ord_Nat:2} = [1, 0]: [START, RVAL := TAILCALL Prelude.Types.compare(v1, v0)]
Prelude.Types.{__Impl_Ord_Nat:1} = [1, 0]: [START, RVAL := TAILCALL Prelude.Types./=(v1, v0)]
Prelude.Types.{__Impl_Ord_Nat:0} = [1, 0]: [START, RVAL := TAILCALL Prelude.Types.==(v1, v0)]
Prelude.Types.Functor implementation at Prelude/Types.idr:332:1--335:36 = [0, 1, 2, 3]: [START, RVAL := TAILCALL Prelude.Types.map(DISCARD, DISCARD, v2, v3)]
Prelude.Types.Eq implementation at Prelude/Types.idr:71:1--75:17 = []: [DECLARE v0, DECLARE v1, START, v0 := MKCLOSURE Prelude.Types.{__Impl_Eq_Nat:0} 2 (), v1 := MKCLOSURE Prelude.Types.{__Impl_Eq_Nat:1} 2 (), RVAL := MKCON Left 0 (v0, v1)]
Prelude.Types.{__Impl_Eq_Nat:1} = [1, 0]: [START, RVAL := TAILCALL Prelude.Types./=(v1, v0)]
Prelude.Types.{__Impl_Eq_Nat:0} = [1, 0]: [START, RVAL := TAILCALL Prelude.Types.==(v1, v0)]
Prelude.Types.> = [0, 1]: [DECLARE v2, DECLARE v3, START, v2 := CALL Prelude.Types.compare(v0, v1), v3 := MKCONSTANT 2, RVAL := TAILCALL Prelude.EqOrd.==(v2, v3)]
Prelude.Types.>= = [0, 1]: [DECLARE v2, DECLARE v3, START, v2 := CALL Prelude.Types.compare(v0, v1), v3 := MKCONSTANT 0, RVAL := TAILCALL Prelude.EqOrd./=(v2, v3)]
Prelude.Types.== = [0, 1]: [DECLARE v3, DECLARE v2, DECLARE v5, DECLARE v4, START, CASE v0 [(0, [CASE v1 [(0, [RVAL := MKCONSTANT 0])] {default: Just [RVAL := MKCONSTANT 1]}])] {default: Just [v3 := MKCONSTANT 1, v2 := OP -Integer(v0, v3), CASE v1 [(0, [RVAL := MKCONSTANT 1])] {default: Just [v5 := MKCONSTANT 1, v4 := OP -Integer(v1, v5), RVAL := TAILCALL Prelude.Types.==(v2, v4)]}]}]
Prelude.Types.< = [0, 1]: [DECLARE v2, DECLARE v3, START, v2 := CALL Prelude.Types.compare(v0, v1), v3 := MKCONSTANT 0, RVAL := TAILCALL Prelude.EqOrd.==(v2, v3)]
Prelude.Types.<= = [0, 1]: [DECLARE v2, DECLARE v3, START, v2 := CALL Prelude.Types.compare(v0, v1), v3 := MKCONSTANT 2, RVAL := TAILCALL Prelude.EqOrd./=(v2, v3)]
Prelude.Types./= = [0, 1]: [DECLARE v2, START, v2 := CALL Prelude.Types.==(v0, v1), RVAL := TAILCALL Prelude.Basics.not(v2)]
Prelude.Types.prim__integerToNat = [0]: [DECLARE v1, DECLARE v2, DECLARE v3, START, v1 := MKCONSTANT 0, v2 := OP <=Integer(v1, v0), CASE v2 [(0, [v3 := MKCONSTANT 1])] {default: Just [v3 := MKCONSTANT 0]}, RVAL := TAILCALL Prelude.Types.case block in prim__integerToNat(v0, v3)]
Prelude.Types.String.++ = [0, 1]: [START, RVAL := OP ++(v0, v1)]
Prelude.Types.List.++ = [0, 1, 2]: [DECLARE v3, DECLARE v4, DECLARE v5, START, CASE v1 [(Left 0, [RVAL := v2]), (Left 1, [v3 := PROJECT(v1, 0), v4 := PROJECT(v1, 1), v5 := CALL Prelude.Types.List.++(DISCARD, v4, v2), RVAL := MKCON Left 1 (v3, v5)])] {default: Nothing}]
Prelude.Num.case block in mod = [0, 1, 2]: [DECLARE v3, START, CASE v2 [(1, [RVAL := OP %Int(v1, v0)])] {default: Just [v3 := MKCONSTANT "Unhandled input for Prelude.Num.case block in mod at Prelude/Num.idr:116:3--118:40", RVAL := TAILCALL Builtin.idris_crash(DISCARD, v3)]}]
Prelude.Num.case block in div = [0, 1, 2]: [DECLARE v3, START, CASE v2 [(1, [RVAL := OP /Int(v1, v0)])] {default: Just [v3 := MKCONSTANT "Unhandled input for Prelude.Num.case block in div at Prelude/Num.idr:113:3--115:40", RVAL := TAILCALL Builtin.idris_crash(DISCARD, v3)]}]
Prelude.Num.case block in mod = [0, 1, 2]: [DECLARE v3, START, CASE v2 [(1, [RVAL := OP %Integer(v1, v0)])] {default: Just [v3 := MKCONSTANT "Unhandled input for Prelude.Num.case block in mod at Prelude/Num.idr:80:3--82:44", RVAL := TAILCALL Builtin.idris_crash(DISCARD, v3)]}]
Prelude.Num.case block in div = [0, 1, 2]: [DECLARE v3, START, CASE v2 [(1, [RVAL := OP /Integer(v1, v0)])] {default: Just [v3 := MKCONSTANT "Unhandled input for Prelude.Num.case block in div at Prelude/Num.idr:77:3--79:44", RVAL := TAILCALL Builtin.idris_crash(DISCARD, v3)]}]
Prelude.Num.negate = [0]: [DECLARE v1, START, v1 := MKCONSTANT 0, RVAL := OP -Integer(v1, v0)]
Prelude.Num.negate = [0]: [DECLARE v1, START, v1 := MKCONSTANT 0, RVAL := OP -Int(v1, v0)]
Prelude.Num.mod = [0, 1]: [DECLARE v2, DECLARE v3, START, v2 := MKCONSTANT 0, v3 := CALL Prelude.EqOrd.==(v1, v2), RVAL := TAILCALL Prelude.Num.case block in mod(v1, v0, v3)]
Prelude.Num.mod = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, START, v2 := MKCONSTANT 0, v3 := OP cast-Integer-Int(v2), v4 := CALL Prelude.EqOrd.==(v1, v3), RVAL := TAILCALL Prelude.Num.case block in mod(v1, v0, v4)]
Prelude.Num.fromInteger = [0]: [START, RVAL := v0]
Prelude.Num.fromInteger = [0]: [START, RVAL := OP cast-Integer-Int(v0)]
Prelude.Num.div = [0, 1]: [DECLARE v2, DECLARE v3, START, v2 := MKCONSTANT 0, v3 := CALL Prelude.EqOrd.==(v1, v2), RVAL := TAILCALL Prelude.Num.case block in div(v1, v0, v3)]
Prelude.Num.div = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, START, v2 := MKCONSTANT 0, v3 := OP cast-Integer-Int(v2), v4 := CALL Prelude.EqOrd.==(v1, v3), RVAL := TAILCALL Prelude.Num.case block in div(v1, v0, v4)]
Prelude.Num.Num implementation at Prelude/Num.idr:59:1--64:19 = []: [DECLARE v0, DECLARE v1, DECLARE v2, START, v0 := MKCLOSURE Prelude.Num.{__Impl_Num_Integer:0} 2 (), v1 := MKCLOSURE Prelude.Num.{__Impl_Num_Integer:1} 2 (), v2 := MKCLOSURE Prelude.Num.{__Impl_Num_Integer:2} 1 (), RVAL := MKCON Left 0 (v0, v1, v2)]
Prelude.Num.{__Impl_Num_Integer:2} = [0]: [START, RVAL := v0]
Prelude.Num.{__Impl_Num_Integer:1} = [1, 0]: [START, RVAL := OP *Integer(v1, v0)]
Prelude.Num.{__Impl_Num_Integer:0} = [1, 0]: [START, RVAL := OP +Integer(v1, v0)]
Prelude.Num.Num implementation at Prelude/Num.idr:95:1--100:38 = []: [DECLARE v0, DECLARE v1, DECLARE v2, START, v0 := MKCLOSURE Prelude.Num.{__Impl_Num_Int:0} 2 (), v1 := MKCLOSURE Prelude.Num.{__Impl_Num_Int:1} 2 (), v2 := MKCLOSURE Prelude.Num.{__Impl_Num_Int:2} 1 (), RVAL := MKCON Left 0 (v0, v1, v2)]
Prelude.Num.{__Impl_Num_Int:2} = [0]: [START, RVAL := OP cast-Integer-Int(v0)]
Prelude.Num.{__Impl_Num_Int:1} = [1, 0]: [START, RVAL := OP *Int(v1, v0)]
Prelude.Num.{__Impl_Num_Int:0} = [1, 0]: [START, RVAL := OP +Int(v1, v0)]
Prelude.Num.Neg implementation at Prelude/Num.idr:66:1--69:26 = []: [DECLARE v0, DECLARE v1, DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, START, v0 := MKCLOSURE Prelude.Num.{__Impl_Neg_Integer:0} 2 (), v1 := MKCLOSURE Prelude.Num.{__Impl_Neg_Integer:1} 2 (), v2 := MKCLOSURE Prelude.Num.{__Impl_Neg_Integer:2} 1 (), v3 := MKCON Left 0 (v0, v1, v2), v4 := MKCLOSURE Prelude.Num.{__Impl_Neg_Integer:3} 1 (), v5 := MKCLOSURE Prelude.Num.{__Impl_Neg_Integer:4} 2 (), RVAL := MKCON Left 0 (v3, v4, v5)]
Prelude.Num.{__Impl_Neg_Integer:4} = [1, 0]: [START, RVAL := TAILCALL Prelude.Num.-(v1, v0)]
Prelude.Num.{__Impl_Neg_Integer:3} = [0]: [START, RVAL := TAILCALL Prelude.Num.negate(v0)]
Prelude.Num.{__Impl_Neg_Integer:2} = [0]: [START, RVAL := v0]
Prelude.Num.{__Impl_Neg_Integer:1} = [1, 0]: [START, RVAL := OP *Integer(v1, v0)]
Prelude.Num.{__Impl_Neg_Integer:0} = [1, 0]: [START, RVAL := OP +Integer(v1, v0)]
Prelude.Num.Neg implementation at Prelude/Num.idr:102:1--105:22 = []: [DECLARE v0, DECLARE v1, DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, START, v0 := MKCLOSURE Prelude.Num.{__Impl_Neg_Int:0} 2 (), v1 := MKCLOSURE Prelude.Num.{__Impl_Neg_Int:1} 2 (), v2 := MKCLOSURE Prelude.Num.{__Impl_Neg_Int:2} 1 (), v3 := MKCON Left 0 (v0, v1, v2), v4 := MKCLOSURE Prelude.Num.{__Impl_Neg_Int:3} 1 (), v5 := MKCLOSURE Prelude.Num.{__Impl_Neg_Int:4} 2 (), RVAL := MKCON Left 0 (v3, v4, v5)]
Prelude.Num.{__Impl_Neg_Int:4} = [1, 0]: [START, RVAL := TAILCALL Prelude.Num.-(v1, v0)]
Prelude.Num.{__Impl_Neg_Int:3} = [0]: [START, RVAL := TAILCALL Prelude.Num.negate(v0)]
Prelude.Num.{__Impl_Neg_Int:2} = [0]: [START, RVAL := OP cast-Integer-Int(v0)]
Prelude.Num.{__Impl_Neg_Int:1} = [1, 0]: [START, RVAL := OP *Int(v1, v0)]
Prelude.Num.{__Impl_Neg_Int:0} = [1, 0]: [START, RVAL := OP +Int(v1, v0)]
Prelude.Num.Integral implementation at Prelude/Num.idr:75:1--82:44 = []: [DECLARE v0, DECLARE v1, DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, START, v0 := MKCLOSURE Prelude.Num.{__Impl_Integral_Integer:0} 2 (), v1 := MKCLOSURE Prelude.Num.{__Impl_Integral_Integer:1} 2 (), v2 := MKCLOSURE Prelude.Num.{__Impl_Integral_Integer:2} 1 (), v3 := MKCON Left 0 (v0, v1, v2), v4 := MKCLOSURE Prelude.Num.{__Impl_Integral_Integer:3} 2 (), v5 := MKCLOSURE Prelude.Num.{__Impl_Integral_Integer:4} 2 (), RVAL := MKCON Left 0 (v3, v4, v5)]
Prelude.Num.{__Impl_Integral_Integer:4} = [1, 0]: [START, RVAL := TAILCALL Prelude.Num.mod(v1, v0)]
Prelude.Num.{__Impl_Integral_Integer:3} = [1, 0]: [START, RVAL := TAILCALL Prelude.Num.div(v1, v0)]
Prelude.Num.{__Impl_Integral_Integer:2} = [0]: [START, RVAL := v0]
Prelude.Num.{__Impl_Integral_Integer:1} = [1, 0]: [START, RVAL := OP *Integer(v1, v0)]
Prelude.Num.{__Impl_Integral_Integer:0} = [1, 0]: [START, RVAL := OP +Integer(v1, v0)]
Prelude.Num.Integral implementation at Prelude/Num.idr:111:1--118:40 = []: [DECLARE v0, DECLARE v1, DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, START, v0 := MKCLOSURE Prelude.Num.{__Impl_Integral_Int:0} 2 (), v1 := MKCLOSURE Prelude.Num.{__Impl_Integral_Int:1} 2 (), v2 := MKCLOSURE Prelude.Num.{__Impl_Integral_Int:2} 1 (), v3 := MKCON Left 0 (v0, v1, v2), v4 := MKCLOSURE Prelude.Num.{__Impl_Integral_Int:3} 2 (), v5 := MKCLOSURE Prelude.Num.{__Impl_Integral_Int:4} 2 (), RVAL := MKCON Left 0 (v3, v4, v5)]
Prelude.Num.{__Impl_Integral_Int:4} = [1, 0]: [START, RVAL := TAILCALL Prelude.Num.mod(v1, v0)]
Prelude.Num.{__Impl_Integral_Int:3} = [1, 0]: [START, RVAL := TAILCALL Prelude.Num.div(v1, v0)]
Prelude.Num.{__Impl_Integral_Int:2} = [0]: [START, RVAL := OP cast-Integer-Int(v0)]
Prelude.Num.{__Impl_Integral_Int:1} = [1, 0]: [START, RVAL := OP *Int(v1, v0)]
Prelude.Num.{__Impl_Integral_Int:0} = [1, 0]: [START, RVAL := OP +Int(v1, v0)]
Prelude.Num.- = [0, 1]: [START, RVAL := OP -Integer(v0, v1)]
Prelude.Num.- = [0, 1]: [START, RVAL := OP -Int(v0, v1)]
Prelude.Num.+ = [0, 1]: [START, RVAL := OP +Integer(v0, v1)]
Prelude.Num.+ = [0, 1]: [START, RVAL := OP +Int(v0, v1)]
Prelude.Num.* = [0, 1]: [START, RVAL := OP *Integer(v0, v1)]
Prelude.Num.* = [0, 1]: [START, RVAL := OP *Int(v0, v1)]
Prelude.Num.mod = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), v4 := PROJECT(v1, 2), RVAL := MKCLOSURE Prelude.Num.{mod:0} 2 (v2, v3, v4, v0, v1)])] {default: Nothing}]
Prelude.Num.{mod:0} = [0, 1, 2, 3, 4, 6, 5]: [DECLARE v7, START, v7 := v2 @ v6, RVAL := v7 @ v5]
Prelude.Num.div = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), v4 := PROJECT(v1, 2), RVAL := MKCLOSURE Prelude.Num.{div:0} 2 (v2, v3, v4, v0, v1)])] {default: Nothing}]
Prelude.Num.{div:0} = [0, 1, 2, 3, 4, 6, 5]: [DECLARE v7, START, v7 := v1 @ v6, RVAL := v7 @ v5]
Prelude.Num.- = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), v4 := PROJECT(v1, 2), RVAL := MKCLOSURE Prelude.Num.{-:0} 2 (v2, v3, v4, v0, v1)])] {default: Nothing}]
Prelude.Num.{-:0} = [0, 1, 2, 3, 4, 6, 5]: [DECLARE v7, START, v7 := v2 @ v6, RVAL := v7 @ v5]
Prelude.Num.+ = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), v4 := PROJECT(v1, 2), RVAL := MKCLOSURE Prelude.Num.{+:0} 2 (v2, v3, v4, v0, v1)])] {default: Nothing}]
Prelude.Num.{+:0} = [0, 1, 2, 3, 4, 6, 5]: [DECLARE v7, START, v7 := v0 @ v6, RVAL := v7 @ v5]
Prelude.Num.* = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), v4 := PROJECT(v1, 2), RVAL := MKCLOSURE Prelude.Num.{*:0} 2 (v2, v3, v4, v0, v1)])] {default: Nothing}]
Prelude.Num.{*:0} = [0, 1, 2, 3, 4, 6, 5]: [DECLARE v7, START, v7 := v1 @ v6, RVAL := v7 @ v5]
Prelude.EqOrd.case block in case block in compare = [0, 1, 2]: [START, CASE v2 [(0, [RVAL := MKCONSTANT 1]), (1, [RVAL := MKCONSTANT 2])] {default: Nothing}]
Prelude.EqOrd.case block in compare = [0, 1, 2]: [DECLARE v3, START, CASE v2 [(0, [RVAL := MKCONSTANT 0]), (1, [v3 := CALL Prelude.EqOrd.==(v1, v0), RVAL := TAILCALL Prelude.EqOrd.case block in case block in compare(v0, v1, v3)])] {default: Nothing}]
Prelude.EqOrd.case block in max = [0, 1, 2]: [START, CASE v2 [(0, [RVAL := v1]), (1, [RVAL := v0])] {default: Nothing}]
Prelude.EqOrd.case block in min = [0, 1, 2]: [START, CASE v2 [(0, [RVAL := v1]), (1, [RVAL := v0])] {default: Nothing}]
Prelude.EqOrd.min = [0, 1]: [DECLARE v2, START, v2 := CALL Prelude.EqOrd.<(v0, v1), RVAL := TAILCALL Prelude.EqOrd.case block in min(v1, v0, v2)]
Prelude.EqOrd.max = [0, 1]: [DECLARE v2, START, v2 := CALL Prelude.EqOrd.>(v0, v1), RVAL := TAILCALL Prelude.EqOrd.case block in max(v1, v0, v2)]
Prelude.EqOrd.compare = [0, 1]: [DECLARE v2, START, v2 := CALL Prelude.EqOrd.<(v0, v1), RVAL := TAILCALL Prelude.EqOrd.case block in compare(v1, v0, v2)]
Prelude.EqOrd.Ord implementation at Prelude/EqOrd.idr:137:1--144:47 = []: [DECLARE v0, DECLARE v1, DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, DECLARE v6, DECLARE v7, DECLARE v8, DECLARE v9, START, v0 := MKCLOSURE Prelude.EqOrd.{__Impl_Ord_Integer:0} 2 (), v1 := MKCLOSURE Prelude.EqOrd.{__Impl_Ord_Integer:1} 2 (), v2 := MKCON Left 0 (v0, v1), v3 := MKCLOSURE Prelude.EqOrd.{__Impl_Ord_Integer:2} 2 (), v4 := MKCLOSURE Prelude.EqOrd.{__Impl_Ord_Integer:3} 2 (), v5 := MKCLOSURE Prelude.EqOrd.{__Impl_Ord_Integer:4} 2 (), v6 := MKCLOSURE Prelude.EqOrd.{__Impl_Ord_Integer:5} 2 (), v7 := MKCLOSURE Prelude.EqOrd.{__Impl_Ord_Integer:6} 2 (), v8 := MKCLOSURE Prelude.EqOrd.{__Impl_Ord_Integer:7} 2 (), v9 := MKCLOSURE Prelude.EqOrd.{__Impl_Ord_Integer:8} 2 (), RVAL := MKCON Left 0 (v2, v3, v4, v5, v6, v7, v8, v9)]
Prelude.EqOrd.{__Impl_Ord_Integer:8} = [1, 0]: [START, RVAL := TAILCALL Prelude.EqOrd.min(v1, v0)]
Prelude.EqOrd.{__Impl_Ord_Integer:7} = [1, 0]: [START, RVAL := TAILCALL Prelude.EqOrd.max(v1, v0)]
Prelude.EqOrd.{__Impl_Ord_Integer:6} = [1, 0]: [START, RVAL := TAILCALL Prelude.EqOrd.>=(v1, v0)]
Prelude.EqOrd.{__Impl_Ord_Integer:5} = [1, 0]: [START, RVAL := TAILCALL Prelude.EqOrd.<=(v1, v0)]
Prelude.EqOrd.{__Impl_Ord_Integer:4} = [1, 0]: [START, RVAL := TAILCALL Prelude.EqOrd.>(v1, v0)]
Prelude.EqOrd.{__Impl_Ord_Integer:3} = [1, 0]: [START, RVAL := TAILCALL Prelude.EqOrd.<(v1, v0)]
Prelude.EqOrd.{__Impl_Ord_Integer:2} = [1, 0]: [START, RVAL := TAILCALL Prelude.EqOrd.compare(v1, v0)]
Prelude.EqOrd.{__Impl_Ord_Integer:1} = [1, 0]: [START, RVAL := TAILCALL Prelude.EqOrd./=(v1, v0)]
Prelude.EqOrd.{__Impl_Ord_Integer:0} = [1, 0]: [START, RVAL := TAILCALL Prelude.EqOrd.==(v1, v0)]
Prelude.EqOrd.Eq implementation at Prelude/EqOrd.idr:79:1--84:19 = []: [DECLARE v0, DECLARE v1, START, v0 := MKCLOSURE Prelude.EqOrd.{__Impl_Eq_Ordering:0} 2 (), v1 := MKCLOSURE Prelude.EqOrd.{__Impl_Eq_Ordering:1} 2 (), RVAL := MKCON Left 0 (v0, v1)]
Prelude.EqOrd.{__Impl_Eq_Ordering:1} = [1, 0]: [START, RVAL := TAILCALL Prelude.EqOrd./=(v1, v0)]
Prelude.EqOrd.{__Impl_Eq_Ordering:0} = [1, 0]: [START, RVAL := TAILCALL Prelude.EqOrd.==(v1, v0)]
Prelude.EqOrd.Eq implementation at Prelude/EqOrd.idr:40:1--42:44 = []: [DECLARE v0, DECLARE v1, START, v0 := MKCLOSURE Prelude.EqOrd.{__Impl_Eq_Integer:0} 2 (), v1 := MKCLOSURE Prelude.EqOrd.{__Impl_Eq_Integer:1} 2 (), RVAL := MKCON Left 0 (v0, v1)]
Prelude.EqOrd.{__Impl_Eq_Integer:1} = [1, 0]: [START, RVAL := TAILCALL Prelude.EqOrd./=(v1, v0)]
Prelude.EqOrd.{__Impl_Eq_Integer:0} = [1, 0]: [START, RVAL := TAILCALL Prelude.EqOrd.==(v1, v0)]
Prelude.EqOrd.> = [0, 1]: [DECLARE v2, START, v2 := OP >Integer(v0, v1), CASE v2 [(0, [RVAL := MKCONSTANT 1])] {default: Just [RVAL := MKCONSTANT 0]}]
Prelude.EqOrd.>= = [0, 1]: [DECLARE v2, START, v2 := OP >=Integer(v0, v1), CASE v2 [(0, [RVAL := MKCONSTANT 1])] {default: Just [RVAL := MKCONSTANT 0]}]
Prelude.EqOrd.== = [0, 1]: [START, CASE v0 [(0, [CASE v1 [(0, [RVAL := MKCONSTANT 0])] {default: Just [RVAL := MKCONSTANT 1]}]), (1, [CASE v1 [(1, [RVAL := MKCONSTANT 0])] {default: Just [RVAL := MKCONSTANT 1]}]), (2, [CASE v1 [(2, [RVAL := MKCONSTANT 0])] {default: Just [RVAL := MKCONSTANT 1]}])] {default: Just [RVAL := MKCONSTANT 1]}]
Prelude.EqOrd.== = [0, 1]: [DECLARE v2, START, v2 := OP ==Integer(v0, v1), CASE v2 [(0, [RVAL := MKCONSTANT 1])] {default: Just [RVAL := MKCONSTANT 0]}]
Prelude.EqOrd.== = [0, 1]: [DECLARE v2, START, v2 := OP ==Int(v0, v1), CASE v2 [(0, [RVAL := MKCONSTANT 1])] {default: Just [RVAL := MKCONSTANT 0]}]
Prelude.EqOrd.== = [0, 1]: [DECLARE v2, START, v2 := OP ==Char(v0, v1), CASE v2 [(0, [RVAL := MKCONSTANT 1])] {default: Just [RVAL := MKCONSTANT 0]}]
Prelude.EqOrd.< = [0, 1]: [DECLARE v2, START, v2 := OP <Integer(v0, v1), CASE v2 [(0, [RVAL := MKCONSTANT 1])] {default: Just [RVAL := MKCONSTANT 0]}]
Prelude.EqOrd.<= = [0, 1]: [DECLARE v2, START, v2 := OP <=Integer(v0, v1), CASE v2 [(0, [RVAL := MKCONSTANT 1])] {default: Just [RVAL := MKCONSTANT 0]}]
Prelude.EqOrd./= = [0, 1]: [DECLARE v2, START, v2 := CALL Prelude.EqOrd.==(v0, v1), RVAL := TAILCALL Prelude.Basics.not(v2)]
Prelude.EqOrd./= = [0, 1]: [DECLARE v2, START, v2 := CALL Prelude.EqOrd.==(v0, v1), RVAL := TAILCALL Prelude.Basics.not(v2)]
Prelude.EqOrd.compare = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, DECLARE v6, DECLARE v7, DECLARE v8, DECLARE v9, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), v4 := PROJECT(v1, 2), v5 := PROJECT(v1, 3), v6 := PROJECT(v1, 4), v7 := PROJECT(v1, 5), v8 := PROJECT(v1, 6), v9 := PROJECT(v1, 7), RVAL := MKCLOSURE Prelude.EqOrd.{compare:0} 2 (v2, v3, v4, v5, v6, v7, v8, v9, v0, v1)])] {default: Nothing}]
Prelude.EqOrd.{compare:0} = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 10]: [DECLARE v12, START, v12 := v1 @ v11, RVAL := v12 @ v10]
Prelude.EqOrd.> = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, DECLARE v6, DECLARE v7, DECLARE v8, DECLARE v9, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), v4 := PROJECT(v1, 2), v5 := PROJECT(v1, 3), v6 := PROJECT(v1, 4), v7 := PROJECT(v1, 5), v8 := PROJECT(v1, 6), v9 := PROJECT(v1, 7), RVAL := MKCLOSURE Prelude.EqOrd.{>:0} 2 (v2, v3, v4, v5, v6, v7, v8, v9, v0, v1)])] {default: Nothing}]
Prelude.EqOrd.{>:0} = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 10]: [DECLARE v12, START, v12 := v3 @ v11, RVAL := v12 @ v10]
Prelude.EqOrd.== = [0, 1]: [DECLARE v2, DECLARE v3, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), RVAL := MKCLOSURE Prelude.EqOrd.{==:0} 2 (v2, v3, v0, v1)])] {default: Nothing}]
Prelude.EqOrd.{==:0} = [0, 1, 2, 3, 5, 4]: [DECLARE v6, START, v6 := v0 @ v5, RVAL := v6 @ v4]
Prelude.EqOrd.< = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, DECLARE v6, DECLARE v7, DECLARE v8, DECLARE v9, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), v4 := PROJECT(v1, 2), v5 := PROJECT(v1, 3), v6 := PROJECT(v1, 4), v7 := PROJECT(v1, 5), v8 := PROJECT(v1, 6), v9 := PROJECT(v1, 7), RVAL := MKCLOSURE Prelude.EqOrd.{<:0} 2 (v2, v3, v4, v5, v6, v7, v8, v9, v0, v1)])] {default: Nothing}]
Prelude.EqOrd.{<:0} = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 10]: [DECLARE v12, START, v12 := v2 @ v11, RVAL := v12 @ v10]
Prelude.Interfaces.map = [0, 1, 2, 3, 4, 5]: [DECLARE v6, DECLARE v7, DECLARE v8, START, v6 := v3 @ DISCARD, v7 := v6 @ DISCARD, v8 := v7 @ v4, RVAL := v8 @ v5]
Prelude.Interfaces.>>= = [0, 1, 2, 3]: [DECLARE v4, DECLARE v5, DECLARE v6, START, CASE v3 [(Left 0, [v4 := PROJECT(v3, 0), v5 := PROJECT(v3, 1), v6 := PROJECT(v3, 2), RVAL := MKCLOSURE Prelude.Interfaces.{>>=:0} 2 (v4, v5, v6, v0, v1, v2, v3)])] {default: Nothing}]
Prelude.Interfaces.{>>=:0} = [0, 1, 2, 3, 4, 5, 6, 8, 7]: [DECLARE v9, DECLARE v10, DECLARE v11, START, v9 := v1 @ DISCARD, v10 := v9 @ DISCARD, v11 := v10 @ v8, RVAL := v11 @ v7]
Prelude.Interfaces.>> = [0, 1, 2, 3, 4]: [DECLARE v5, DECLARE v6, DECLARE v7, DECLARE v8, DECLARE v9, DECLARE v10, DECLARE v11, START, CASE v2 [(Left 0, [v5 := PROJECT(v2, 0), v6 := PROJECT(v2, 1), v7 := PROJECT(v2, 2), v8 := v6 @ DISCARD, v9 := v8 @ DISCARD, v10 := v9 @ v3, v11 := MKCLOSURE Prelude.Interfaces.{>>:0} 1 (v5, v6, v7, v0, v1, v2, v3, v4), RVAL := v10 @ v11])] {default: Nothing}]
Prelude.Interfaces.{>>:0} = [0, 1, 2, 3, 4, 5, 6, 7, 8]: [START, RVAL := v7 @ DISCARD]
PrimIO.case block in unsafePerformIO = [0, 1, 2, 3]: [START, RVAL := TAILCALL PrimIO.unsafeDestroyWorld(DISCARD, DISCARD, v3)]
PrimIO.case block in case block in io_bind = [0, 1, 2, 3, 4, 5, 6, 7]: [START, RVAL := v7 @ v6]
PrimIO.case block in io_bind = [0, 1, 2, 3, 4, 5]: [DECLARE v6, START, v6 := v3 @ v5, RVAL := TAILCALL PrimIO.case block in case block in io_bind(DISCARD, DISCARD, DISCARD, DISCARD, DISCARD, v5, DISCARD, v6)]
PrimIO.unsafePerformIO = [0, 1]: [DECLARE v2, START, v2 := MKCLOSURE PrimIO.{unsafePerformIO:0} 1 (v0, v1), RVAL := TAILCALL PrimIO.unsafeCreateWorld(DISCARD, v2)]
PrimIO.{unsafePerformIO:0} = [0, 1, 2]: [DECLARE v3, START, v3 := v1 @ v2, RVAL := TAILCALL PrimIO.case block in unsafePerformIO(DISCARD, v1, DISCARD, v3)]
PrimIO.unsafeDestroyWorld = [0, 1, 2]: [START, RVAL := v2]
PrimIO.unsafeCreateWorld = [0, 1]: [DECLARE v2, START, v2 := MKCONSTANT %MkWorld, RVAL := v1 @ v2]
PrimIO.io_pure = [0, 1, 2]: [START, RVAL := v1]
PrimIO.io_bind = [0, 1, 2, 3, 4]: [DECLARE v5, START, v5 := v2 @ v4, RVAL := TAILCALL PrimIO.case block in io_bind(DISCARD, DISCARD, DISCARD, v3, DISCARD, v5)]
PrimIO.fromPrim = [0, 1]: [START, RVAL := v1]
Prelude.Show.case block in max = [0, 1, 2]: [START, CASE v2 [(0, [RVAL := v1]), (1, [RVAL := v0])] {default: Nothing}]
Prelude.Show.case block in min = [0, 1, 2]: [START, CASE v2 [(0, [RVAL := v1]), (1, [RVAL := v0])] {default: Nothing}]
Prelude.Show.2121:6234:show' = [0, 1, 2, 3, 4]: [DECLARE v5, DECLARE v6, DECLARE v7, DECLARE v8, DECLARE v9, DECLARE v10, DECLARE v11, DECLARE v12, DECLARE v13, DECLARE v14, DECLARE v15, START, CASE v4 [(Left 0, [RVAL := v3]), (Left 1, [v5 := PROJECT(v4, 0), v6 := PROJECT(v4, 1), CASE v6 [(Left 0, [CASE v1 [(Left 0, [v7 := PROJECT(v1, 0), v8 := PROJECT(v1, 1), v9 := v7 @ v5])] {default: Nothing}, RVAL := TAILCALL Prelude.Types.String.++(v3, v9)])] {default: Just [CASE v1 [(Left 0, [v10 := PROJECT(v1, 0), v11 := PROJECT(v1, 1), v12 := v10 @ v5])] {default: Nothing}, v13 := MKCONSTANT ", ", v14 := CALL Prelude.Types.String.++(v12, v13), v15 := CALL Prelude.Types.String.++(v3, v14), RVAL := TAILCALL Prelude.Show.2121:6234:show'(DISCARD, v1, v2, v15, v6)]}])] {default: Nothing}]
Prelude.Show.show = [0]: [DECLARE v1, START, v1 := MKCON Left 0 (), RVAL := TAILCALL Prelude.Show.showPrec(v1, v0)]
Prelude.Show.show = [0]: [DECLARE v1, START, v1 := MKCON Left 0 (), RVAL := TAILCALL Prelude.Show.showPrec(v1, v0)]
Prelude.Show.show = [0, 1, 2]: [DECLARE v6, DECLARE v3, DECLARE v4, DECLARE v5, DECLARE v7, START, v6 := MKCONSTANT "[", v3 := MKCONSTANT "", v4 := CALL Prelude.Show.2121:6234:show'(DISCARD, v1, v2, v3, v2), v5 := MKCONSTANT "]", v7 := CALL Prelude.Types.String.++(v4, v5), RVAL := TAILCALL Prelude.Types.String.++(v6, v7)]
Prelude.Show.showPrec = [0, 1]: [DECLARE v2, START, v2 := MKCLOSURE Prelude.Show.{showPrec_Show_Integer:0} 1 (v0, v1), RVAL := TAILCALL Prelude.Show.primNumShow(DISCARD, v2, v0, v1)]
Prelude.Show.{showPrec_Show_Integer:0} = [0, 1, 2]: [START, RVAL := OP cast-Integer-String(v2)]
Prelude.Show.showPrec = [0, 1]: [DECLARE v2, START, v2 := MKCLOSURE Prelude.Show.{showPrec_Show_Int:0} 1 (v0, v1), RVAL := TAILCALL Prelude.Show.primNumShow(DISCARD, v2, v0, v1)]
Prelude.Show.{showPrec_Show_Int:0} = [0, 1, 2]: [START, RVAL := OP cast-Int-String(v2)]
Prelude.Show.showPrec = [0, 1, 2, 3]: [START, RVAL := TAILCALL Prelude.Show.show(DISCARD, v1, v3)]
Prelude.Show.min = [0, 1]: [DECLARE v2, START, v2 := CALL Prelude.Show.<(v0, v1), RVAL := TAILCALL Prelude.Show.case block in min(v1, v0, v2)]
Prelude.Show.max = [0, 1]: [DECLARE v2, START, v2 := CALL Prelude.Show.>(v0, v1), RVAL := TAILCALL Prelude.Show.case block in max(v1, v0, v2)]
Prelude.Show.compare = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, DECLARE v6, DECLARE v7, START, CASE v0 [(Left 4, [v2 := PROJECT(v0, 0), CASE v1 [(Left 4, [v3 := PROJECT(v1, 0), RVAL := TAILCALL Prelude.Types.compare(v2, v3)])] {default: Just [v4 := CALL Prelude.Show.precCon(v0), v5 := CALL Prelude.Show.precCon(v1), RVAL := TAILCALL Prelude.EqOrd.compare(v4, v5)]}])] {default: Just [v6 := CALL Prelude.Show.precCon(v0), v7 := CALL Prelude.Show.precCon(v1), RVAL := TAILCALL Prelude.EqOrd.compare(v6, v7)]}]
Prelude.Show.Show implementation at Prelude/Show.idr:106:1--108:50 = []: [DECLARE v0, DECLARE v1, START, v0 := MKCLOSURE Prelude.Show.{__Impl_Show_Integer:0} 1 (), v1 := MKCLOSURE Prelude.Show.{__Impl_Show_Integer:1} 2 (), RVAL := MKCON Left 0 (v0, v1)]
Prelude.Show.{__Impl_Show_Integer:1} = [1, 0]: [START, RVAL := TAILCALL Prelude.Show.showPrec(v1, v0)]
Prelude.Show.{__Impl_Show_Integer:0} = [0]: [START, RVAL := TAILCALL Prelude.Show.show(v0)]
Prelude.Show.Show implementation at Prelude/Show.idr:102:1--104:46 = []: [DECLARE v0, DECLARE v1, START, v0 := MKCLOSURE Prelude.Show.{__Impl_Show_Int:0} 1 (), v1 := MKCLOSURE Prelude.Show.{__Impl_Show_Int:1} 2 (), RVAL := MKCON Left 0 (v0, v1)]
Prelude.Show.{__Impl_Show_Int:1} = [1, 0]: [START, RVAL := TAILCALL Prelude.Show.showPrec(v1, v0)]
Prelude.Show.{__Impl_Show_Int:0} = [0]: [START, RVAL := TAILCALL Prelude.Show.show(v0)]
Prelude.Show.Show implementation at Prelude/Show.idr:198:1--205:61 = [0, 1]: [DECLARE v2, DECLARE v3, START, v2 := MKCLOSURE Prelude.Show.{__Impl_Show_(List $a):0} 1 (v0, v1), v3 := MKCLOSURE Prelude.Show.{__Impl_Show_(List $a):1} 2 (v0, v1), RVAL := MKCON Left 0 (v2, v3)]
Prelude.Show.{__Impl_Show_(List $a):1} = [0, 1, 3, 2]: [START, RVAL := TAILCALL Prelude.Show.showPrec(DISCARD, v1, v3, v2)]
Prelude.Show.{__Impl_Show_(List $a):0} = [0, 1, 2]: [START, RVAL := TAILCALL Prelude.Show.show(DISCARD, v1, v2)]
Prelude.Show.Ord implementation at Prelude/Show.idr:36:1--39:62 = []: [DECLARE v0, DECLARE v1, DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, DECLARE v6, DECLARE v7, DECLARE v8, DECLARE v9, START, v0 := MKCLOSURE Prelude.Show.{__Impl_Ord_Prec:0} 2 (), v1 := MKCLOSURE Prelude.Show.{__Impl_Ord_Prec:1} 2 (), v2 := MKCON Left 0 (v0, v1), v3 := MKCLOSURE Prelude.Show.{__Impl_Ord_Prec:2} 2 (), v4 := MKCLOSURE Prelude.Show.{__Impl_Ord_Prec:3} 2 (), v5 := MKCLOSURE Prelude.Show.{__Impl_Ord_Prec:4} 2 (), v6 := MKCLOSURE Prelude.Show.{__Impl_Ord_Prec:5} 2 (), v7 := MKCLOSURE Prelude.Show.{__Impl_Ord_Prec:6} 2 (), v8 := MKCLOSURE Prelude.Show.{__Impl_Ord_Prec:7} 2 (), v9 := MKCLOSURE Prelude.Show.{__Impl_Ord_Prec:8} 2 (), RVAL := MKCON Left 0 (v2, v3, v4, v5, v6, v7, v8, v9)]
Prelude.Show.{__Impl_Ord_Prec:8} = [1, 0]: [START, RVAL := TAILCALL Prelude.Show.min(v1, v0)]
Prelude.Show.{__Impl_Ord_Prec:7} = [1, 0]: [START, RVAL := TAILCALL Prelude.Show.max(v1, v0)]
Prelude.Show.{__Impl_Ord_Prec:6} = [1, 0]: [START, RVAL := TAILCALL Prelude.Show.>=(v1, v0)]
Prelude.Show.{__Impl_Ord_Prec:5} = [1, 0]: [START, RVAL := TAILCALL Prelude.Show.<=(v1, v0)]
Prelude.Show.{__Impl_Ord_Prec:4} = [1, 0]: [START, RVAL := TAILCALL Prelude.Show.>(v1, v0)]
Prelude.Show.{__Impl_Ord_Prec:3} = [1, 0]: [START, RVAL := TAILCALL Prelude.Show.<(v1, v0)]
Prelude.Show.{__Impl_Ord_Prec:2} = [1, 0]: [START, RVAL := TAILCALL Prelude.Show.compare(v1, v0)]
Prelude.Show.{__Impl_Ord_Prec:1} = [1, 0]: [START, RVAL := TAILCALL Prelude.Show./=(v1, v0)]
Prelude.Show.{__Impl_Ord_Prec:0} = [1, 0]: [START, RVAL := TAILCALL Prelude.Show.==(v1, v0)]
Prelude.Show.Eq implementation at Prelude/Show.idr:31:1--34:50 = []: [DECLARE v0, DECLARE v1, START, v0 := MKCLOSURE Prelude.Show.{__Impl_Eq_Prec:0} 2 (), v1 := MKCLOSURE Prelude.Show.{__Impl_Eq_Prec:1} 2 (), RVAL := MKCON Left 0 (v0, v1)]
Prelude.Show.{__Impl_Eq_Prec:1} = [1, 0]: [START, RVAL := TAILCALL Prelude.Show./=(v1, v0)]
Prelude.Show.{__Impl_Eq_Prec:0} = [1, 0]: [START, RVAL := TAILCALL Prelude.Show.==(v1, v0)]
Prelude.Show.> = [0, 1]: [DECLARE v2, DECLARE v3, START, v2 := CALL Prelude.Show.compare(v0, v1), v3 := MKCONSTANT 2, RVAL := TAILCALL Prelude.EqOrd.==(v2, v3)]
Prelude.Show.>= = [0, 1]: [DECLARE v2, DECLARE v3, START, v2 := CALL Prelude.Show.compare(v0, v1), v3 := MKCONSTANT 0, RVAL := TAILCALL Prelude.EqOrd./=(v2, v3)]
Prelude.Show.== = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, DECLARE v6, DECLARE v7, START, CASE v0 [(Left 4, [v2 := PROJECT(v0, 0), CASE v1 [(Left 4, [v3 := PROJECT(v1, 0), RVAL := TAILCALL Prelude.Types.==(v2, v3)])] {default: Just [v4 := CALL Prelude.Show.precCon(v0), v5 := CALL Prelude.Show.precCon(v1), RVAL := TAILCALL Prelude.EqOrd.==(v4, v5)]}])] {default: Just [v6 := CALL Prelude.Show.precCon(v0), v7 := CALL Prelude.Show.precCon(v1), RVAL := TAILCALL Prelude.EqOrd.==(v6, v7)]}]
Prelude.Show.< = [0, 1]: [DECLARE v2, DECLARE v3, START, v2 := CALL Prelude.Show.compare(v0, v1), v3 := MKCONSTANT 0, RVAL := TAILCALL Prelude.EqOrd.==(v2, v3)]
Prelude.Show.<= = [0, 1]: [DECLARE v2, DECLARE v3, START, v2 := CALL Prelude.Show.compare(v0, v1), v3 := MKCONSTANT 2, RVAL := TAILCALL Prelude.EqOrd./=(v2, v3)]
Prelude.Show./= = [0, 1]: [DECLARE v2, START, v2 := CALL Prelude.Show.==(v0, v1), RVAL := TAILCALL Prelude.Basics.not(v2)]
Prelude.Show.showPrec = [0, 1]: [DECLARE v2, DECLARE v3, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), RVAL := MKCLOSURE Prelude.Show.{showPrec:0} 2 (v2, v3, v0, v1)])] {default: Nothing}]
Prelude.Show.{showPrec:0} = [0, 1, 2, 3, 5, 4]: [DECLARE v6, START, v6 := v1 @ v5, RVAL := v6 @ v4]
Prelude.Show.showParens = [0, 1]: [DECLARE v3, DECLARE v2, DECLARE v4, START, CASE v0 [(1, [RVAL := v1]), (0, [v3 := MKCONSTANT "(", v2 := MKCONSTANT ")", v4 := CALL Prelude.Types.String.++(v1, v2), RVAL := TAILCALL Prelude.Types.String.++(v3, v4)])] {default: Nothing}]
Prelude.Show.show = [0, 1]: [DECLARE v2, DECLARE v3, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), RVAL := MKCLOSURE Prelude.Show.{show:0} 1 (v2, v3, v0, v1)])] {default: Nothing}]
Prelude.Show.{show:0} = [0, 1, 2, 3, 4]: [START, RVAL := v0 @ v4]
Prelude.Show.primNumShow = [0, 1, 2, 3]: [DECLARE v4, DECLARE v5, DECLARE v6, DECLARE v7, DECLARE v8, START, v4 := v1 @ v3, v5 := MKCON Left 5 (), v6 := CALL Prelude.Show.>=(v2, v5), v7 := MKCLOSURE Prelude.Show.{primNumShow:1} 1 (v4, v0, v1, v2, v3), v8 := CALL Prelude.Basics.&&(v6, v7), RVAL := TAILCALL Prelude.Show.showParens(v8, v4)]
Prelude.Show.{primNumShow:1} = [0, 1, 2, 3, 4, 5]: [DECLARE v6, START, v6 := MKCLOSURE Prelude.Show.{primNumShow:0} 1 (v5, v0, v1, v2, v3, v4), RVAL := TAILCALL Prelude.Show.firstCharIs(v6, v0)]
Prelude.Show.{primNumShow:0} = [0, 1, 2, 3, 4, 5, 6]: [DECLARE v7, START, v7 := MKCONSTANT '-', RVAL := TAILCALL Prelude.EqOrd.==(v6, v7)]
Prelude.Show.precCon = [0]: [DECLARE v1, START, CASE v0 [(Left 0, [RVAL := MKCONSTANT 0]), (Left 1, [RVAL := MKCONSTANT 1]), (Left 2, [RVAL := MKCONSTANT 2]), (Left 3, [RVAL := MKCONSTANT 3]), (Left 4, [v1 := PROJECT(v0, 0), RVAL := MKCONSTANT 4]), (Left 5, [RVAL := MKCONSTANT 5]), (Left 6, [RVAL := MKCONSTANT 6])] {default: Nothing}]
Prelude.Show.firstCharIs = [0, 1]: [DECLARE v2, START, CASE v1 [("", [RVAL := MKCONSTANT 1])] {default: Just [v2 := OP op_strhead(v1), RVAL := v0 @ v2]}]
Prelude.IO.pure = [0, 1, 2]: [START, RVAL := v1]
Prelude.IO.map = [0, 1, 2, 3, 4]: [DECLARE v5, START, v5 := v3 @ v4, RVAL := v2 @ v5]
Prelude.IO.liftIO = [0, 1, 2, 3]: [DECLARE v4, DECLARE v5, DECLARE v6, START, CASE v2 [(Left 0, [v4 := PROJECT(v2, 0), v5 := PROJECT(v2, 1), v6 := v5 @ DISCARD, RVAL := v6 @ v3])] {default: Nothing}]
Prelude.IO.liftIO1 = [0, 1]: [START, RVAL := v1]
Prelude.IO.join = [0, 1, 2]: [DECLARE v3, START, v3 := v1 @ v2, RVAL := v3 @ v2]
Prelude.IO.Monad implementation at Prelude/IO.idr:28:1--31:24 = []: [DECLARE v0, DECLARE v1, DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, START, v0 := MKCLOSURE Prelude.IO.{__Impl_Monad_IO:0} 5 (), v1 := MKCLOSURE Prelude.IO.{__Impl_Monad_IO:1} 3 (), v2 := MKCLOSURE Prelude.IO.{__Impl_Monad_IO:2} 5 (), v3 := MKCON Left 0 (v0, v1, v2), v4 := MKCLOSURE Prelude.IO.{__Impl_Monad_IO:3} 5 (), v5 := MKCLOSURE Prelude.IO.{__Impl_Monad_IO:4} 3 (), RVAL := MKCON Left 0 (v3, v4, v5)]
Prelude.IO.{__Impl_Monad_IO:4} = [2, 1, 0]: [DECLARE v3, START, v3 := v1 @ v0, RVAL := v3 @ v0]
Prelude.IO.{__Impl_Monad_IO:3} = [4, 3, 2, 1, 0]: [DECLARE v5, DECLARE v6, START, v5 := v2 @ v0, v6 := v1 @ v5, RVAL := v6 @ v0]
Prelude.IO.{__Impl_Monad_IO:2} = [4, 3, 2, 1, 0]: [DECLARE v5, DECLARE v6, START, v5 := v2 @ v0, v6 := v1 @ v0, RVAL := v5 @ v6]
Prelude.IO.{__Impl_Monad_IO:1} = [2, 1, 0]: [START, RVAL := v1]
Prelude.IO.{__Impl_Monad_IO:0} = [4, 3, 2, 1, 0]: [START, RVAL := TAILCALL Prelude.IO.map(DISCARD, DISCARD, v2, v1, v0)]
Prelude.IO.HasLinearIO implementation at Prelude/IO.idr:41:1--43:16 = []: [DECLARE v0, DECLARE v1, DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, DECLARE v6, DECLARE v7, START, v0 := MKCLOSURE Prelude.IO.{__Impl_HasLinearIO_IO:0} 5 (), v1 := MKCLOSURE Prelude.IO.{__Impl_HasLinearIO_IO:1} 3 (), v2 := MKCLOSURE Prelude.IO.{__Impl_HasLinearIO_IO:2} 5 (), v3 := MKCON Left 0 (v0, v1, v2), v4 := MKCLOSURE Prelude.IO.{__Impl_HasLinearIO_IO:3} 5 (), v5 := MKCLOSURE Prelude.IO.{__Impl_HasLinearIO_IO:4} 3 (), v6 := MKCON Left 0 (v3, v4, v5), v7 := MKCLOSURE Prelude.IO.{__Impl_HasLinearIO_IO:5} 2 (), RVAL := MKCON Left 0 (v6, v7)]
Prelude.IO.{__Impl_HasLinearIO_IO:5} = [1, 0]: [START, RVAL := v0]
Prelude.IO.{__Impl_HasLinearIO_IO:4} = [2, 1, 0]: [DECLARE v3, START, v3 := v1 @ v0, RVAL := v3 @ v0]
Prelude.IO.{__Impl_HasLinearIO_IO:3} = [4, 3, 2, 1, 0]: [DECLARE v5, DECLARE v6, START, v5 := v2 @ v0, v6 := v1 @ v5, RVAL := v6 @ v0]
Prelude.IO.{__Impl_HasLinearIO_IO:2} = [4, 3, 2, 1, 0]: [DECLARE v5, DECLARE v6, START, v5 := v2 @ v0, v6 := v1 @ v0, RVAL := v5 @ v6]
Prelude.IO.{__Impl_HasLinearIO_IO:1} = [2, 1, 0]: [START, RVAL := v1]
Prelude.IO.{__Impl_HasLinearIO_IO:0} = [4, 3, 2, 1, 0]: [START, RVAL := TAILCALL Prelude.IO.map(DISCARD, DISCARD, v2, v1, v0)]
Prelude.IO.HasIO implementation at Prelude/IO.idr:45:1--47:23 = [0, 1]: [DECLARE v2, DECLARE v3, DECLARE v4, DECLARE v5, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), v4 := v2])] {default: Nothing}, v5 := MKCLOSURE Prelude.IO.{__Impl_HasIO_$io:0} 2 (v0, v1), RVAL := MKCON Left 0 (v4, v5)]
Prelude.IO.{__Impl_HasIO_$io:0} = [0, 1, 3, 2]: [DECLARE v4, DECLARE v5, DECLARE v6, START, CASE v1 [(Left 0, [v4 := PROJECT(v1, 0), v5 := PROJECT(v1, 1), v6 := v5 @ DISCARD, RVAL := v6 @ v2])] {default: Nothing}]
Prelude.IO.Functor implementation at Prelude/IO.idr:15:1--17:46 = [0, 1, 2, 3, 4]: [START, RVAL := TAILCALL Prelude.IO.map(DISCARD, DISCARD, v2, v3, v4)]
Prelude.IO.Applicative implementation at Prelude/IO.idr:19:1--26:30 = []: [DECLARE v0, DECLARE v1, DECLARE v2, START, v0 := MKCLOSURE Prelude.IO.{__Impl_Applicative_IO:0} 5 (), v1 := MKCLOSURE Prelude.IO.{__Impl_Applicative_IO:1} 3 (), v2 := MKCLOSURE Prelude.IO.{__Impl_Applicative_IO:2} 5 (), RVAL := MKCON Left 0 (v0, v1, v2)]
Prelude.IO.{__Impl_Applicative_IO:2} = [4, 3, 2, 1, 0]: [DECLARE v5, DECLARE v6, START, v5 := v2 @ v0, v6 := v1 @ v0, RVAL := v5 @ v6]
Prelude.IO.{__Impl_Applicative_IO:1} = [2, 1, 0]: [START, RVAL := v1]
Prelude.IO.{__Impl_Applicative_IO:0} = [4, 3, 2, 1, 0]: [START, RVAL := TAILCALL Prelude.IO.map(DISCARD, DISCARD, v2, v1, v0)]
Prelude.IO.Constraint (Monad io) = [0, 1]: [DECLARE v2, DECLARE v3, START, CASE v1 [(Left 0, [v2 := PROJECT(v1, 0), v3 := PROJECT(v1, 1), RVAL := v2])] {default: Nothing}]
Prelude.IO.>>= = [0, 1, 2, 3, 4]: [DECLARE v5, DECLARE v6, START, v5 := v2 @ v4, v6 := v3 @ v5, RVAL := v6 @ v4]
Prelude.IO.<*> = [0, 1, 2, 3, 4]: [DECLARE v5, DECLARE v6, START, v5 := v2 @ v4, v6 := v3 @ v4, RVAL := v5 @ v6]
Prelude.IO.putStrLn = [0, 1, 2]: [DECLARE v3, DECLARE v4, START, v3 := MKCONSTANT "\n", v4 := OP ++(v2, v3), RVAL := TAILCALL Prelude.IO.putStr(DISCARD, v1, v4)]
Prelude.IO.putStr = [0, 1, 2]: [DECLARE v3, DECLARE v4, DECLARE v5, DECLARE v6, START, CASE v1 [(Left 0, [v3 := PROJECT(v1, 0), v4 := PROJECT(v1, 1), v5 := v4 @ DISCARD, v6 := MKCLOSURE Prelude.IO.{putStr:0} 1 (v3, v4, v0, v1, v2), RVAL := v5 @ v6])] {default: Nothing}]
Prelude.IO.{putStr:0} = [0, 1, 2, 3, 4, 5]: [START, RVAL := TAILCALL Prelude.IO.prim__putStr(v4, v5)]
Prelude.IO.primIO = [0, 1, 2, 3]: [DECLARE v4, DECLARE v5, DECLARE v6, START, CASE v2 [(Left 0, [v4 := PROJECT(v2, 0), v5 := PROJECT(v2, 1), v6 := v5 @ DISCARD, RVAL := v6 @ v3])] {default: Nothing}]
Prelude.IO.liftIO1 = [0, 1, 2]: [DECLARE v3, DECLARE v4, START, CASE v2 [(Left 0, [v3 := PROJECT(v2, 0), v4 := PROJECT(v2, 1), RVAL := MKCLOSURE Prelude.IO.{liftIO1:0} 1 (v3, v4, v0, v1, v2)])] {default: Nothing}]
Prelude.IO.{liftIO1:0} = [0, 1, 2, 3, 4, 5]: [DECLARE v6, START, v6 := v1 @ DISCARD, RVAL := v6 @ v5]
Prelude.IO.liftIO = [0, 1, 2]: [DECLARE v3, DECLARE v4, START, CASE v2 [(Left 0, [v3 := PROJECT(v2, 0), v4 := PROJECT(v2, 1), RVAL := MKCLOSURE Prelude.IO.{liftIO:0} 1 (v3, v4, v0, v1, v2)])] {default: Nothing}]
Prelude.IO.{liftIO:0} = [0, 1, 2, 3, 4, 5]: [DECLARE v6, START, v6 := v1 @ DISCARD, RVAL := v6 @ v5]
